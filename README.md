## 1. Оценка сложности алгоритма по времени  

**Временная сложность алгоритма** — это функция, которая показывает, как изменяется количество выполняемых операций (или время работы) алгоритма в зависимости от размера входных данных `n`.

> Цель оценки: понять, как быстро растёт время работы при увеличении объёма данных.

| Вид оценки             | Обозначение | Описание                                                                                |
| ---------------------- | ----------- | --------------------------------------------------------------------------------------- |
| **Оценка сверху**      | `O(f(n))`   | Время работы растёт не быстрее, чем `f(n)` (в худшем случае).                           |
| **Оценка снизу**       | `Ω(f(n))`   | Время работы растёт не медленнее, чем `f(n)` (в лучшем случае).                         |
| **Точная асимптотика** | `Θ(f(n))`   | Время работы растёт _ровно_ как `f(n)` — и сверху, и снизу ограничено (средний случай). |

- **Большое O:**  
    `T(n) = O(f(n))`, если ∃ константы `c > 0` и `n₀`, такие что  
    `T(n) ≤ c * f(n)` для всех `n ≥ n₀`.
    
- **Большое Ω:**  
    `T(n) = Ω(f(n))`, если ∃ константы `c > 0` и `n₀`, такие что  
    `T(n) ≥ c * f(n)` для всех `n ≥ n₀`.
    
- **Большое Θ:**  
    `T(n) = Θ(f(n))`, если `T(n)` одновременно `O(f(n))` и `Ω(f(n))`.

| Сценарий           | Обозначение | Пример                                           |
| ------------------ | ----------- | ------------------------------------------------ |
| **Лучший случай**  | `Ω(f(n))`   | Быстрый выход из поиска (первый элемент найден). |
| **Худший случай**  | `O(f(n))`   | Элемент отсутствует, нужно проверить всё.        |
| **Средний случай** | `Θ(f(n))`   | Ожидаемое время при случайных данных.            |
### Практические приёмы

1. **Игнорировать константы и младшие члены:**  
    `3n² + 10n + 5 → O(n²)`
    
2. **Суммировать вложенные циклы:**  
    Если циклы вложены, умножай итерации (`n * n` → `O(n²)`).
    
3. **Если циклы последовательны**, то складывать:  
    `O(n) + O(n²) = O(n²)` (берётся старший порядок).
    
4. **Следить за рекурсией:**  
    используем **рекуррентные соотношения** для оценки 
    (`T(n) = 2T(n/2) + O(n)` → `O(n log n)`).


## 2. Оценка сложности алгоритма по памяти  

**Пространственная сложность** — это функция, показывающая, **сколько памяти** использует алгоритм в зависимости от размера входных данных `n`.

> Она показывает, как быстро растёт объём необходимой памяти при увеличении входа.

| Компонент                      | Пример                             | Тип                   |
| ------------------------------ | ---------------------------------- | --------------------- |
| **Входные данные**             | массив `a[n]`, структура графа     | постоянная часть      |
| **Выходные данные**            | результирующий массив, дерево      | постоянная часть      |
| **Вспомогательные переменные** | счётчики, временные буферы         | дополнительная память |
| **Память под рекурсию**        | стек вызовов, локальные переменные | дополнительная память |
| **Динамические структуры**     | векторы, списки, хэш-таблицы       | дополнительная память |

При оценке сложности учитывают:
- переменные (в том числе временные),
- массивы, структуры, объекты, выделенные динамически (`new`, `malloc`),
- стек рекурсии,
- иногда — память под константы (если существенна).
    

Обычно _входные и выходные данные не включаются_ в оценку — интересует именно **дополнительная память**, которую требует алгоритм.

| Тип          | Обозначение            | Что означает                                   |
| ------------ | ---------------------- | ---------------------------------------------- |
| **O(1)**     | Константная память     | Кол-во памяти не зависит от `n`                |
| **O(log n)** | Логарифмическая память | Например, глубина рекурсии при бинарном поиске |
| **O(n)**     | Линейная память        | Доп. массив, список                            |
| **O(n²)**    | Квадратичная память    | Матрицы, таблицы динамики                      |
### Стек вызовов и рекурсия

Каждый рекурсивный вызов создаёт в стеке:
- адрес возврата,
- локальные переменные,
- параметры функции.
    
Если глубина рекурсии `k`, то суммарная память под стек — `O(k)`.

> Поэтому часто рекурсивные алгоритмы оптимизируют в **итеративные**, чтобы уменьшить использование памяти.

Пример для _merge sort_: 
- Память на стек засчет рекурсии: `O(log n)`
- Копии массивов на слиянии: `O(n)`
- Общая память: `O(n)` (так как `n >> log n`)





## 3. Сортировка вставками  

### Идея сортировки

1. Первый элемент массива считаем уже отсортированным.
2. Берём следующий элемент и **вставляем** его в правильное место **среди уже отсортированных** элементов слева.
3. Повторяем для всех элементов массива.

Сортировка _устойчивая_.

### Пример

Пусть массив:  
`[5, 2, 4, 6, 1, 3]`

| Шаг | Текущий элемент | После вставки                       |
| --- | --------------- | ----------------------------------- |
| 1   | 2               | `[2, 5, 4, 6, 1, 3]`                |
| 2   | 4               | `[2, 4, 5, 6, 1, 3]`                |
| 3   | 6               | `[2, 4, 5, 6, 1, 3]` (уже на месте) |
| 4   | 1               | `[1, 2, 4, 5, 6, 3]`                |
| 5   | 3               | `[1, 2, 3, 4, 5, 6]`                |

### Реализация алгоритма

```cpp
void InsertionSort(int* arr, int size) {
	for (int i = 1; i < size; i++) {
		int current = arr[i];
		int j = i - 1;
		for (; j >= 0 %% arr[j] > current; j--) {
			arr[j + 1] = arr[j];
		}
		arr[j + 1] = current;
	}
}
```

### Асимптотическая сложность

| Случай                            | Количество сравнений и сдвигов                                         | Время     |
| --------------------------------- | ---------------------------------------------------------------------- | --------- |
| **Лучший (уже отсортирован)**     | каждый `a[i]` ≥ предыдущего → внутренний цикл не выполняется           | **O(n)**  |
| **Худший (обратно отсортирован)** | каждый элемент нужно вставлять в начало → сдвигов: `1 + 2 + … + (n−1)` | **O(n²)** |
| **Средний**                       | примерно половина элементов сдвигается                                 | **O(n²)** |
### Пространственная сложность

- Использует только несколько дополнительных переменных (`current`, `i`, `j`)  
    **O(1)** 

## 4. Сортировка слиянием  

**Сортировка слиянием (Merge Sort)** — это алгоритм сортировки, основанный на принципе **разделяй и властвуй**.  
Он рекурсивно делит массив на две части, сортирует каждую из них, а затем **сливает** (merge) эти части в один отсортированный массив.

Сортировка _устойчивая_.
### Идея сортировки

- **Разделение:**  
    Разбиваем массив на две половины.
    
- **Властвование:**  
    Рекурсивно сортируем каждую половину. (Сортировка на подъеме по дереву рекурсии).
    
- **Объединение:**  
    Сливаем две отсортированные половины в один массив.

### Пример

Массив: `[5, 2, 4, 6, 1, 3]`

Разделение:
`[5, 2, 4] | [6, 1, 3]`
`[5, 2] [4] | [6, 1] [3]`
`[5] [2] [4] [6] [1] [3]`

Слияние:
`[2, 5, 4] | [1, 3, 6]`
`[2, 4, 5] | [1, 3, 6]`
`[1, 2, 3, 4, 5, 6]`

### Реализация алгоритма

```cpp
void merge(int arr[], int left, int mid, int right) {
	int size_left = mid - left + 1;    // рамер левого подмассива
	int size_right = right - mid;    // размер правого подмассива
	
	int* arr_left = new int[size_left];    // создаем временные массивы
	int* arr_right = new int [size_right];
	
	for (int i = 0; i < size_left; i++) {    // копируем в них данные
		arr_left[i] = arr[left + i];
	}
	for (int j = 0; j < size_right; j++) {
		arr_right[j] = arr[mid + 1 + j];
	}
	
	int i = 0, j = 0, k = left;    // сливаем 2 массива в 1
	while (i < size_left && j < size_right) {
		if (arr_left[i] <= arr_right[j]) {
			arr[k] = arr_left[i];
			i++;
		} else {
			arr[k] = arr_right[j];
			j++;
		}
		k++;
	}
	
	while (i < size_left) {     // добавляем оставшиеся элементы
		arr[k] = arr_left[i];   // (один массив может закончится раньше...
		i++;                    // ... другого)
		k++;
	}
	
	while (j < size_right) {
		arr[k] = arr_right[j];
		j++;
		k++;
	}
	
	delete[] arr_left;
	delete[] arr_right;
}

void merge_sort(int arr[], int left, int right) {
	if (left >= right) return;   // выход из рекурсии
	int mid = left + (right - left) / 2;
	merge_sort(arr, left, mid);
	merge_sort(arr, mid + 1, right);
	merge(arr, left, mid, right);
}
```

### Временная сложность

Алгоритм всегда делает:

- **деление** массива на 2 части → `log₂(n)` уровней рекурсии,
    
- **слияние** всех элементов на каждом уровне → `O(n)` операций на уровень.
    

Общая сложность:

`T(n) = 2T(n/2) + O(n)`

Используя **Мастер-теорему**:

`T(n) = O(n log n)`

И это — **во всех случаях** (лучший, средний, худший).

### Пространственная сложность

Во время слияния создаётся временный массив (`O(n)` элементов).  
Также есть рекурсивный стек глубиной `O(log n)`.

**Общая память:**

`O(n) + O(log n) ≈ O(n)`

## 5. Быстрая сортировка  

**Быстрая сортировка (Quick Sort)** — это алгоритм сортировки, основанный на принципе **разделяй и властвуй**.  
Она рекурсивно делит массив на две части относительно некоторого **опорного элемента (pivot)**, сортируя их независимо.

Не является устойчивой.

### Основная идея

1. Выбирается **опорный элемент** `pivot`.
2. Все элементы, **меньшие pivot**, перемещаются влево, а **большие — вправо**.
3. Рекурсивно сортируются левая и правая части.
    
После завершения рекурсии массив становится отсортированным.

### Пример

Пусть массив:  
`[5, 2, 9, 1, 7, 3]`

- pivot = 3
- разделяем: `[2, 1] | 3 | [9, 7, 5]`
- рекурсивно сортируем левую и правую части → `[1, 2, 3, 5, 7, 9]`

### Реализация

#### Вариант 1 — Разбиение Ломуто (через последний элемент)

```cpp
void quick_sort(int* arr, int low, int high) {
	if (low >= high) {
		return;    // выход из рекурсии, если массив пустой или длины 1
	}
	int pivot = arr[high];    // опорный элемент, разделяющий arr на 2 части
	int i = low - 1;    // arr[i] - последний элемент arr, который <= pivot
	for (int j = low; j < high; j++) {    // проходим по arr[j], кроме pivot
		if (arr[j] <= pivot) {    // проверяем, в какую часть arr попадет эл-т
			i++;    // расширяем область для эл-тов, меньших pivot
			std::swap(arr[i], arr[j]);    // перемещаем эл-т в область
		}
	}
	std::swap(arr[i+1], arr[high])    // ставим pivot в конце области
	int pivot_index = i + 1;    // запоминаем позицию pivot
	quick_sort(arr, low, pivot_index - 1);    // рекурсия для левой части arr 
	quick_sort(arr, pivot_index + 1, high);    //рекурсия для правой части arr
}
```

**Особенности:**
- Простая реализация.
- Требует больше обменов.
- Плохо работает при множестве одинаковых элементов.

#### Вариант 2 — Ломуто с рандомным pivot

Чтобы избежать **деградации до O(n²)** при неудачном выборе опорного элемента (например, если массив уже отсортирован),  
используется **рандомизация pivot**:

```cpp
#include <cstdlib>

void QuickSort(int* arr, int low, int high) {
	if (low <= high) {
		return;
	}
	rand_index = low + rand() % (high - low + 1);
	std::swap(arr[rand_index], arr[high]);
	int pivot = arr[high];
	int i = low - 1;
	for (int j = low; j < high; j++) {
		if (arr[j] <= pivot) {
			i++;
			std::swap(arr[i], arr[j]);
		}
	std::swap(arr[i + 1], arr[high]);
	int pivot_index = i + 1;
	QuickSort(arr, low, pivot_index - 1);
	QuickSort(arr, pivot_index + 1, high);
	}
}
```

**Преимущество:**  
Рандомизация делает вероятность худшего случая (O(n²)) **практически нулевой** → ожидаемое время **O(n log n)**.
#### Вариант 3 — Разбиение Хоара

```cpp
void QuickSort(int* arr, int low, int high) {
	if (low >= high) {
		return;
	}
	int pivot = arr[(low + high) / 2];
	int i = low - 1;
	int j = high + 1;
	while (true) {
		do {
			i++;
		} while (arr[i] < pivot);
		
		do {
			j--;
		} while (arr[j] > pivot);
	
		if (i >= j) {
			break;
		}
		std::swap(arr[i], arr[j]);
	}
	QuickSort(arr, low, j);
	QuickSort(arr, j + 1, high);
}
```

##### Почему Хоара выгоднее

|Сравнение|Ломуто|Хоара|
|---|---|---|
|**Количество обменов**|Больше — каждый элемент ≤ pivot может меняться местами|Меньше — обмен происходит только при нарушении порядка|
|**Количество сравнений**|Чуть больше|Меньше (≈ на 20–30%)|
|**Эффективность на больших массивах**|Ниже|Выше|
|**Чувствительность к равным элементам**|Сильно замедляется|Работает стабильнее|
|**Диапазон рекурсий**|pivot всегда на своём месте → может быть перекос|Делит массив более сбалансированно|

**Итого:**  
Алгоритм Хоара обычно **в 1.3–1.5 раза быстрее**,  
и требует **меньше операций** в среднем.

### Временная сложность

| Случай      | Разделение массива                                      | Время        |
| ----------- | ------------------------------------------------------- | ------------ |
| **Лучший**  | почти равные части                                      | `O(n log n)` |
| **Средний** | случайное распределение                                 | `O(n log n)` |
| **Худший**  | один из подмассивов пустой (уже отсортированный массив) | `O(n²)`      |
### Пространственная сложность

- Рекурсивная глубина стека:
    - **в среднем** — `O(log n)`
    - **в худшем случае** — `O(n)` (если деление сильно неравномерное)


## 6. Сортировка подсчетом  

**Сортировка подсчётом (Counting Sort)** — это не сравнивающая сортировка,  
работающая за **O(n + k)**, где `n` — количество элементов, а `k` — диапазон возможных значений.

### Идея алгоритма

Если известно, что элементы массива — это **целые числа из ограниченного диапазона**,  
можно просто посчитать, сколько раз встречается каждое значение, а затем восстановить массив в отсортированном виде.

_Устойчивость_ сортировки зависит от реализации.
### Пример

Пусть массив:

`[4, 2, 2, 8, 3, 3, 1]`

Подсчёт количества вхождений:

`Значение:     1  2  3  4  5  6  7  8`
`Количество:   1  2  2  1  0  0  0  1`

Восстановление массива по счётчикам:

`[1, 2, 2, 3, 3, 4, 8]`

### Реализация

для чисел в диапазоне 100 (неустойчивая):
```cpp
void count_sort(int* arr, int size) {
    int* count_arr = new int[100]();  // важно инициализировать нулями

    // Подсчёт количества вхождений каждого числа
    for (int i = 0; i < size; i++) {
        count_arr[arr[i] - 1]++;      // -1, т.к. индексация с 0
    }

    int k = 0;

    // Восстановление отсортированного массива
    for (int i = 0; i < 100; i++) {
        while (count_arr[i]-- > 0) {
            arr[k++] = i + 1;         // +1, чтобы вернуть исходное значение
        }
    }

    delete[] count_arr;
}
```

устойчивая реализация через префиксные суммы:
```cpp
void count_sort(int* arr, int n, int max_val) {
    // 1️⃣ Создаём вспомогательные массивы
    int* count = new int[max_val + 1]{0}; // массив частот
    int* output = new int[n];              // результирующий массив (для устойчивости)

    // 2️⃣ Подсчитываем количество вхождений каждого значения
    for (int i = 0; i < n; i++)
        count[arr[i]]++;

    // 3️⃣ Преобразуем count[] в префиксные суммы
    // Теперь count[i] хранит индекс последнего элемента со значением i
    for (int i = 1; i <= max_val; i++)
        count[i] += count[i - 1];

    // 4️⃣ Формируем выходной массив (справа налево — для устойчивости)
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;  // уменьшаем индекс для следующего такого же значения
    }

    // 5️⃣ Копируем результат обратно в arr[]
    for (int i = 0; i < n; i++)
        arr[i] = output[i];

    delete[] count;
    delete[] output;
}
```
#### Пояснение работы

1. **Создаётся вспомогательный массив `count_arr`** длиной `k` (здесь 100).  
    В `count_arr[i]` хранится количество элементов, равных `i+1`.
    
2. **Заполняем `count_arr`**:  
    Проходим по всем элементам исходного массива и увеличиваем соответствующий счётчик.
    
3. **Формируем результат**:  
    Проходим по `count_arr`, и для каждого числа, встречающегося `count_arr[i]` раз,  
    записываем это число в итоговый массив.

### Временная сложность

Сортировка подсчётом проходит два этапа:

1. **Подсчёт элементов** — один проход по массиву `O(n)`
2. **Восстановление отсортированного массива** — проход по диапазону значений `O(k)`
    
Таким образом: `O(n + k)`
где
- `n` — число элементов,
- `k` — размер диапазона возможных значений.
    
Если `k` ограничено константой (например, числа от 1 до 100), то алгоритм работает **за линейное время O(n)**.  
Если же диапазон очень велик (`k >> n`), эффективность падает.

### Пространственная сложность

Сортировка использует дополнительный массив счётчиков размером `k`.
Таким образом: `O(k)` 
Counting Sort выгоден **только при сравнительно малом диапазоне значений**.


## 7. Цифровая сортировка  

### Идея

**Цифровая сортировка (Radix Sort)** — это алгоритм, который сортирует числа **поразрядно**, начиная **с младших разрядов (LSD)** или **со старших (MSD)**.  
На каждом шаге используется **устойчивая сортировка** (обычно **Counting Sort**) по текущему разряду.

Алгоритм не сравнивает элементы напрямую, а обрабатывает их **по цифрам** (или битам, символам и т. д.).

### LSD (Least Significant Digit first)

Сортировка **с наименее значащего разряда**.

**Идея:**

- Сначала сортируем числа по **единицам** (последний разряд),
- потом по **десяткам**, потом по **сотням** и т.д.
- Поскольку используем _устойчивую сортировку_, порядок для одинаковых цифр сохраняется.

#### Пример

Сортируем `[329, 457, 657, 839, 436, 720, 355]`

|Шаг|Разряд|После сортировки|
|---|---|---|
|1|единицы|[720, 355, 436, 457, 657, 839, 329]|
|2|десятки|[720, 329, 436, 839, 355, 457, 657]|
|3|сотни|[329, 355, 436, 457, 657, 720, 839]|
#### Реализация

```cpp
int get_max(int* arr, int size) {
    int mx = arr[0];
    for (int i = 1; i < size; i++)
        if (arr[i] > mx) mx = arr[i];
    return mx;
}

void radix_sort_LSD(int* arr, int size) {
    int max_val = get_max(arr, size);
    for (int exp = 1; max_val / exp > 0; exp *= 10)
        count_sort_digit(arr, size, exp);
}
```


### MSD (Most Significant Digit first)

**Сортировка со старших разрядов.**  
Алгоритм сначала сортирует по самому старшему разряду, а затем **рекурсивно** сортирует каждую подгруппу по следующему разряду.  
Используется для *чисел переменной длины или строк.

#### Пример

**Исходный массив:**

`[329, 457, 657, 839, 436, 720, 355]`

Сортируем по **разрядам слева направо** (сотни → десятки → единицы).

---

##### Шаг 1. Сотни (`exp = 100`)

Разбиение по первой цифре:

|Сотни|Элементы|
|---|---|
|3|329, 355|
|4|436, 457|
|6|657|
|7|720|
|8|839|

После этого массив выглядит так:

`[329, 355, 436, 457, 657, 720, 839]`

---

##### Шаг 2. Рекурсивная сортировка внутри групп

| Группа        | Сортировка по десяткам (`exp = 10`) | Результат     |
| ------------- | ----------------------------------- | ------------- |
| 3**xx**       | [329, 355] → [329, 355]             | без изменений |
| 4**xx**       | [436, 457] → [436, 457]             | без изменений |
| 6xx, 7xx, 8xx | по одному элементу                  | без изменений |

---

##### Результат

После рекурсий получаем:

`[329, 355, 436, 457, 657, 720, 839]`

---

**Вывод:**  
MSD сортирует числа, начиная со старших разрядов, разбивая их на подмассивы.  
Каждая подгруппа затем рекурсивно сортируется по более младшим разрядам.  
Порядок сохраняется внутри групп → алгоритм устойчив.

#### Реализация

```cpp
void msd_sort_rec(int* arr, int left, int right, int exp) {
    if (left >= right || exp == 0)
        return;

    int count[10] = {0};
    int output[10000];

    // Подсчёт цифр
    for (int i = left; i <= right; i++) {
        int digit = (arr[i] / exp) % 10;
        count[digit]++;
    }

    // Префиксные суммы
    for (int i = 1; i < 10; i++)
        count[i] += count[i - 1];

    // Распределение элементов справа налево
    for (int i = right; i >= left; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }

    // Копирование обратно
    for (int i = 0; i < right - left + 1; i++)
        arr[left + i] = output[i];

    // Рекурсивная сортировка по более младшим разрядам
    int start = left;
    for (int d = 0; d < 10; d++) {
        int end = left + count[d] - 1;
        if (start < end)
            msd_sort_rec(arr, start, end, exp / 10);
        start = end + 1;
    }
}

int get_exp(int max_val) {
    int exp = 1;
    while (max_val / exp >= 10)
        exp *= 10;
    return exp;
}

void radix_sort_MSD(int* arr, int size) {
    int max_val = get_max(arr, size);
    int exp = get_exp(max_val);
    msd_sort_rec(arr, 0, size - 1, exp);
}
```

### Сравнение LSD и MSD

| Характеристика              | **LSD**                   | **MSD**                      |
| --------------------------- | ------------------------- | ---------------------------- |
| Направление обработки       | с младших разрядов        | со старших разрядов          |
| Реализация                  | итеративная               | рекурсивная                  |
| Требует устойчивости        | обязательно               | желательно                   |
| Подходит для                | чисел фиксированной длины | чисел/строк переменной длины |
| Типичная область применения | числа                     | строки, слова                |
### Асимптотика

| Показатель   | Оценка                                                               |
| ------------ | -------------------------------------------------------------------- |
| Время        | **O(d · (n + k))**, где `d` — число разрядов, `k` — размер алфавита  |
| Память       | **O(n + k)**                                                         |
| Устойчивость | ✅ LSD — да, MSD — обычно да                                          |

## 8. Стек  

### Определение

**Стек (Stack)** — это структура данных, работающая по принципу  
**LIFO (Last In — First Out)** — _последний вошёл, первый вышел._

> Пример: стопка тарелок — снимаем сверху, добавляем сверху.

### Основные операции

| Операция           | Описание                              | Асимптотика |
| ------------------ | ------------------------------------- | ----------- |
| `push(x)`          | добавить элемент `x` на вершину стека | **O(1)**    |
| `pop()`            | удалить верхний элемент               | **O(1)**    |
| `top()` / `peek()` | вернуть верхний элемент (не удаляя)   | **O(1)**    |
| `empty()`          | проверить, пуст ли стек               | **O(1)**    |
| `size()`           | вернуть количество элементов          | **O(1)**    |
по памяти также `O(1)`

### Использование стека

| Применение                   | Пример                             |
| ---------------------------- | ---------------------------------- |
| Хранение истории действий    | отмена действий в редакторах       |
| Проверка правильности скобок | `((a+b)*c)`                        |
| Обход в глубину (DFS)        | стек заменяет рекурсию             |
| Перевод выражений            | из инфиксной в постфиксную форму   |
| Вычисление выражений         | с помощью обратной польской записи |
| Обратный порядок элементов   | например, реверс строки            |

## 9. Очередь  

### Определение

**Очередь (Queue)** — это структура данных, работающая по принципу  
**FIFO (First In — First Out)** — _первый вошёл, первый вышел._

> Пример: очередь в магазине — кто первый пришёл, тот первый обслужен.

### Основные операции

|Операция|Описание|Асимптотика|
|---|---|---|
|`push(x)`|добавить элемент в конец очереди|**O(1)**|
|`pop()`|удалить элемент из начала очереди|**O(1)**|
|`front()`|получить первый элемент (не удаляя)|**O(1)**|
|`empty()`|проверить, пуста ли очередь|**O(1)**|
|`size()`|вернуть количество элементов|**O(1)**|

по памяти также `O(1)`

### Использование очереди

| Применение                  | Пример                              |
| --------------------------- | ----------------------------------- |
| Обработка задач по порядку  | планировщик процессов               |
| BFS (поиск в ширину)        | алгоритмы на графах                 |
| Буферизация данных          | ввод-вывод, потоки                  |
| Очереди событий             | обработка входных сообщений         |
| Симуляция реальных очередей | моделирование касс, клиентов и т.д. |
|                             |                                     |

## 10. Односвязный список  

### Определение

**Односвязный список (Singly Linked List)** — это динамическая структура данных,  
состоящая из узлов (**node**), где каждый узел хранит:

1. **значение (data)**
2. **указатель на следующий элемент (next)**
    

> В отличие от массива, элементы списка не расположены подряд в памяти —  
> каждый элемент знает только о следующем.


### Структура узла

```cpp
struct Node {
    int value;    // значение
    Node* next;   // указатель на следующий элемент
    Node(int val) {
        value = val;
        next = nullptr;
    }
};
```


### Основные операции

|Операция|Описание|Асимптотика по времени|
|---|---|---|
|`push_front(x)`|вставка в начало|O(1)|
|`push_back(x)`|вставка в конец|O(n)|
|`pop_front()`|удаление из начала|O(1)|
|`pop_back()`|удаление из конца|O(n)|
|`insert(pos, x)`|вставка по индексу|O(n)|
|`remove(pos)`|удаление по индексу|O(n)|
|`find(x)`|поиск элемента|O(n)|
|`empty()`|проверка на пустоту|O(1)|
|`size()`|длина списка|O(n)|
по памяти `O(1)`
### Реализация

```cpp
#include <iostream>

struct Node {
    int value;    // значение
    Node* next;   // указатель на следующий элемент
    Node(int val) {
        value = val;
        next = nullptr;
    }
};

class SinglyLinkedList {
private:
    Node* head;

public:
    SinglyLinkedList() : head(nullptr) {}

    ~SinglyLinkedList() {
        while (head != nullptr) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }

    void push_front(int x) {
        Node* node = new Node(x);
        node->next = head;
        head = node;
    }

    void push_back(int x) {
        Node* node = new Node(x);
        if (!head) {
            head = node;
            return;
        }
        Node* cur = head;
        while (cur->next) cur = cur->next;
        cur->next = node;
    }

    void pop_front() {
        if (!head) return;
        Node* temp = head;
        head = head->next;
        delete temp;
    }

    void pop_back() {
        if (!head) return;
        if (!head->next) {
            delete head;
            head = nullptr;
            return;
        }
        Node* cur = head;
        while (cur->next->next) cur = cur->next;
        delete cur->next;
        cur->next = nullptr;
    }

    void print() {
        Node* cur = head;
        while (cur) {
            std::cout << cur->data << " ";
            cur = cur->next;
        }
        std::cout << "\n";
    }
};
```


### Особенности и отличия от массива

| Характеристика   | Односвязный список                   | Массив                          |
| ---------------- | ------------------------------------ | ------------------------------- |
| Память           | динамическая (каждый элемент в куче) | непрерывный участок             |
| Индексация       | ❌ нет прямого доступа                | ✅ по индексу                    |
| Вставка/удаление | эффективна в начале                  | дорогая (сдвиги)                |
| Перемещение      | только вперёд                        | двустороннее                    |
| Рост структуры   | гибкий (без перераспределений)       | требует realoc при переполнении |
### Использование

- Реализация **стека**, **очереди**, **хэш-таблиц** (цепочки)
- Работа с **неизвестным числом элементов**
- Когда важны **вставки и удаления**, а не быстрый доступ



## 11. Двусвязный список  

### Определение

**Двусвязный список (Doubly Linked List)** — структура данных,  
в которой каждый элемент (**узел**) хранит:

1. **значение (data)**
    
2. **указатель на предыдущий элемент (prev)**
    
3. **указатель на следующий элемент (next)**
    

> Это расширение односвязного списка, позволяющее двигаться **в обе стороны**.

### Структура узла

```cpp
struct Node {
    int value;
    Node* next;
    Node* prev;
    Node(int val) {
        value = val;
        next = nullptr;
        prev = nullptr;
    }
};
```

### Основные операции

| Операция         | Описание                     | Асимптотика |
| ---------------- | ---------------------------- | ----------- |
| `push_front(x)`  | добавить в начало            | O(1)        |
| `push_back(x)`   | добавить в конец             | O(1)        |
| `pop_front()`    | удалить из начала            | O(1)        |
| `pop_back()`     | удалить из конца             | O(1)        |
| `insert(pos, x)` | вставка в произвольное место | O(n)        |
| `remove(pos)`    | удаление по индексу          | O(n)        |
| `find(x)`        | поиск элемента               | O(n)        |
| `empty()`        | проверка на пустоту          | O(1)        |
по памяти `O(1)`

### Реализация двусвязного списка

```cpp
#include <iostream>

struct Node {
    int value;
    Node* next;
    Node* prev;
    Node(int val) {
        value = val;
        next = nullptr;
        prev = nullptr;
    }
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}

    ~DoublyLinkedList() {
        while (head) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }

    void push_front(int x) {
        Node* node = new Node(x);
        node->next = head;
        if (head) head->prev = node;
        else tail = node; // если список был пуст
        head = node;
    }

    void push_back(int x) {
        Node* node = new Node(x);
        node->prev = tail;
        if (tail) tail->next = node;
        else head = node;
        tail = node;
    }

    void pop_front() {
        if (!head) return;
        Node* temp = head;
        head = head->next;
        if (head) head->prev = nullptr;
        else tail = nullptr;
        delete temp;
    }

    void pop_back() {
        if (!tail) return;
        Node* temp = tail;
        tail = tail->prev;
        if (tail) tail->next = nullptr;
        else head = nullptr;
        delete temp;
    }

    void print_forward() {
        for (Node* cur = head; cur; cur = cur->next)
            std::cout << cur->data << " ";
        std::cout << "\n";
    }

    void print_backward() {
        for (Node* cur = tail; cur; cur = cur->prev)
            std::cout << cur->data << " ";
        std::cout << "\n";
    }
};
```

### Сравнение с односвязным списком

|Свойство|Односвязный|Двусвязный|
|---|---|---|
|Указатели|1 (`next`)|2 (`prev`, `next`)|
|Память на элемент|меньше|больше|
|Движение по списку|только вперёд|вперёд и назад|
|Удаление из конца|O(n)|O(1)|
|Вставка перед элементом|O(n)|O(1) (если есть указатель)|
|Сложность реализации|проще|сложнее|
|Удаление по указателю|O(1)|O(1)|




## 12. Циклический список  

### Определение

**Циклический список (Circular Linked List)** — это разновидность связного списка,  
в котором **последний элемент указывает не на `nullptr`, а на первый элемент списка**.

> Таким образом, элементы образуют **замкнутый цикл**.  
> Может быть **односвязным** или **двусвязным**.

### Типы циклических списков

|Вид|Описание|
|---|---|
|**Циклический односвязный**|`next` последнего узла указывает на `head`|
|**Циклический двусвязный**|`next` последнего указывает на `head`, а `prev` первого — на `tail`|
### Преимущества

- Нет "конца" списка — удобно для **круговых структур данных**
    
- Можно **эффективно обходить** все элементы в цикле
    
- Используется в **круговых очередях**, **играх (передача хода)**, **операционных системах (планирование процессов)**
### Основные операции

| Операция        | Описание             | Время |
| --------------- | -------------------- | ----- |
| `push_front(x)` | вставка в начало     | O(1)  |
| `push_back(x)`  | вставка в конец      | O(n)  |
| `pop_front()`   | удаление из начала   | O(1)  |
| `pop_back()`    | удаление из конца    | O(n)  |
| `print()`       | обход всех элементов | O(n)  |
по памяти `O(1)`
### Реализация циклического **односвязного** списка

```cpp
#include <iostream>

struct Node {
    int value;
    Node* next;
    Node(int val) {
        value = val;
        next = nullptr;
    }
};

class CircularList {
private:
    Node* tail;  // удобнее хранить указатель на конец списка

public:
    CircularList() : tail(nullptr) {}

    ~CircularList() {
        if (!tail) return;
        Node* cur = tail->next;
        do {
            Node* temp = cur;
            cur = cur->next;
            delete temp;
        } while (cur != tail->next);
        tail = nullptr;
    }

    void push_back(int x) {
        Node* node = new Node(x);
        if (!tail) {
            tail = node;
            tail->next = tail; // единственный элемент указывает на себя
            return;
        }
        node->next = tail->next;
        tail->next = node;
        tail = node;
    }

    void push_front(int x) {
        Node* node = new Node(x);
        if (!tail) {
            tail = node;
            tail->next = tail;
            return;
        }
        node->next = tail->next;
        tail->next = node;
    }

    void pop_front() {
        if (!tail) return;
        Node* head = tail->next;
        if (head == tail) { // единственный элемент
            delete head;
            tail = nullptr;
            return;
        }
        tail->next = head->next;
        delete head;
    }

    void print() {
        if (!tail) return;
        Node* cur = tail->next; // начинаем с головы
        do {
            std::cout << cur->value << " ";
            cur = cur->next;
        } while (cur != tail->next);
        std::cout << "\n";
    }
};
```


### Реализация циклического **двусвязного** списка

```cpp
struct Node {
    int value;
    Node* next;
    Node* prev;
    Node(int val) {
        value = val;
        next = nullptr;
        prev = nullptr;
    }
};

class DoublyCircularList {
private:
    Node* head;

public:
    DoublyCircularList() : head(nullptr) {}

    void push_back(int x) {
        Node* node = new Node(x);
        if (!head) {
            head = node;
            head->next = head;
            head->prev = head;
            return;
        }
        Node* tail = head->prev;
        tail->next = node;
        node->prev = tail;
        node->next = head;
        head->prev = node;
    }

    void print_forward() {
        if (!head) return;
        Node* cur = head;
        do {
            std::cout << cur->value << " ";
            cur = cur->next;
        } while (cur != head);
        std::cout << "\n";
    }
};
```


## 13. Стек на списках  

### Преимущества реализации на списке

- не нужно заранее задавать размер  
- операции выполняются за **O(1)**  
- не требуется перемещать элементы при вставке или удалении

### Реализация стека на односвязном списке

```cpp
#include <iostream>

struct Node {
    int value;
    Node* next;
    Node(int val) {
        value = val;
        next = nullptr;
    }
};

class Stack {
private:
    Node* top_node;  // вершина стека
    int count;

public:
    Stack() {
        top_node = nullptr;
        count = 0;
    }

    ~Stack() {
        while (top_node) {
            pop();
        }
    }

    void push(int x) {
        Node* node = new Node(x);
        node->next = top_node;
        top_node = node;
        count++;
    }

    void pop() {
        if (!top_node) return;
        Node* temp = top_node;
        top_node = top_node->next;
        delete temp;
        count--;
    }

    int top() {
        if (!top_node) {
            std::cout << "Stack is empty\n";
            return -1;
        }
        return top_node->value;
    }

    bool empty() {
        return top_node == nullptr;
    }

    int size() {
        return count;
    }
};
```


### Асимптотический анализ

|Операция|Время|Память|
|---|---|---|
|`push()`|O(1)|O(1)|
|`pop()`|O(1)|O(1)|
|`top()`|O(1)|O(1)|
|`empty()` / `size()`|O(1)|O(1)|

### Применение

| Область                   | Пример                            |
| ------------------------- | --------------------------------- |
| Рекурсия                  | хранение контекста вызовов        |
| Обратная запись выражений | вычисление постфиксных выражений  |
| Парсинг                   | проверка скобок, разбор выражений |
| Алгоритмы на графах       | DFS (поиск в глубину)             |
| Отмена операций           | undo/redo в текстовых редакторах  |

## 14. Очередь на списках  

### Преимущества реализации на списке

- не нужно заранее задавать размер  
- нет переполнения (в отличие от массивов)  
- операции `push` и `pop` выполняются за **O(1)**  
- память выделяется только под реально существующие элементы
### Реализация очереди на односвязном списке
```cpp
#include <iostream>

struct Node {
    int value;
    Node* next;
    Node(int val) {
        value = val;
        next = nullptr;
    }
};

class Queue {
private:
    Node* front_node; // указатель на начало очереди
    Node* rear_node;  // указатель на конец очереди
    int count;

public:
    Queue() {
        front_node = nullptr;
        rear_node = nullptr;
        count = 0;
    }

    ~Queue() {
        while (!empty()) {
            pop();
        }
    }

    void push(int x) {
        Node* node = new Node(x);
        if (!rear_node) {
            front_node = rear_node = node;
        } else {
            rear_node->next = node;
            rear_node = node;
        }
        count++;
    }

    void pop() {
        if (!front_node) return;
        Node* temp = front_node;
        front_node = front_node->next;
        if (!front_node) rear_node = nullptr;
        delete temp;
        count--;
    }

    int front() {
        if (!front_node) {
            std::cout << "Queue is empty\n";
            return -1;
        }
        return front_node->value;
    }

    bool empty() {
        return front_node == nullptr;
    }

    int size() {
        return count;
    }
};
```

### Асимптотический анализ

| Операция             | Время | Память |     |
| -------------------- | ----- | ------ | --- |
| `push()`             | O(1)  | O(1)   |     |
| `pop()`              | O(1)  | O(1)   |     |
| `front()`            | O(1)  | O(1)   |     |
| `empty()` / `size()` | O(1)  | O(1)   |     |
### Применение

| Область                     | Пример                         |
| --------------------------- | ------------------------------ |
| **Обработка событий**       | обработка запросов, сообщений  |
| **Алгоритмы на графах**     | BFS (поиск в ширину)           |
| **Моделирование процессов** | симуляция очередей, клиентов   |
| **Буферизация данных**      | очереди печати, сетевые буферы |
## 15. Пирамида (построение пирамиды, восстановление свойств пирамиды)  

### Определение

**Пирамида (куча, heap)** — это **полное бинарное дерево**, удовлетворяющее **свойству кучи**:

- **Для max-heap**: каждый родитель ≥ своих потомков
    
- **Для min-heap**: каждый родитель ≤ своих потомков
    

Пирамиду часто хранят **в виде массива**, а не в виде указателей на узлы.  
Это позволяет просто вычислять индексы потомков:

```cpp
left(i) = 2 * i + 1;
right(i) = 2 * i + 2;
parent(i) = (i - 1) / 2;
```

### Пример max-heap

```
          10
        /    \
      7        5
     / \      / \
    2   1    3   4

```

Массивное представление:  
`[10, 7, 5, 2, 1, 3, 4]`


### Основные операции

|Операция|Описание|Сложность|
|---|---|---|
|**heapify_down(i)**|восстановление свойства кучи вниз|O(log n)|
|**heapify_up(i)**|восстановление свойства кучи вверх|O(log n)|
|**build_heap()**|построение кучи из массива|O(n)|
|**insert(x)**|добавление нового элемента|O(log n)|
|**extract_max()**|извлечение максимального (min для min-heap)|O(log n)|

### Восстановление свойств пирамиды

#### **1. Просеивание вниз (heapify_down)**

Используется, если нарушено свойство кучи в корне или у родителя.

**Идея:** сравнить элемент с детьми и, если он меньше (для max-heap), поменять местами с наибольшим из них.

```cpp
void heapify_down(int* arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify_down(arr, n, largest);
    }
}
```

### **2. Просеивание вверх (heapify_up)**

Используется после вставки нового элемента в конец.

**Идея:** сравниваем элемент с родителем и поднимаем вверх, пока не восстановится свойство кучи.

```cpp
void heapify_up(int* arr, int i) {
    while (i > 0 && arr[(i - 1) / 2] < arr[i]) {
        std::swap(arr[i], arr[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}
```


## 16. Построение пирамиды O(n)  

### Построение пирамиды (build_heap)

Чтобы из неупорядоченного массива построить кучу, выполняется **просеивание вниз (heapify_down)**, начиная с последнего родителя:

```cpp
void heapify_down(int* arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify_down(arr, n, largest);
    }
}

void build_heap(int* arr, int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify_down(arr, n, i);
    }
}
```


### Почему сложность O(n), а не O(n log n)

На первый взгляд кажется, что раз `heapify_down` — O(log n), а вызывается он для `n/2` элементов,  
то должно быть `O(n log n)`.  
Но это **ошибочно**, потому что не каждый узел просеивается на всю глубину.

### Математический вывод: почему построение пирамиды — **O(n)**

### Структура дерева

Пирамида — это **почти полное бинарное дерево**.  
Высота дерева:
```
h = ⌊log₂ n⌋
```

Уровни считаем **от низа вверх**:

- уровень `0` — листья,
    
- уровень `1` — родители листьев,
    
- …
    
- уровень `h` — корень.

### Сколько узлов на уровне `k`

На нижнем уровне (`k = 0`) примерно половина всех узлов — это листья.  
Чем выше уровень, тем меньше узлов —  
каждый уровень содержит вдвое меньше узлов, чем предыдущий.

Примерно:

```
число узлов на уровне k ≈ n / 2^(k + 1)
```

### Сколько работы делает каждый узел

Операция `heapify_down(i)` (просеивание вниз)  
может затронуть максимум `k` уровней, если узел находится на уровне `k` (от низа).

Поэтому стоимость одной операции на уровне `k`: `≈ O(k)`

### Суммируем вклад всех уровней

Общая трудоёмкость:

`T(n) = сумма (число узлов на уровне) × (стоимость heapify_down)`

`T(n) = ∑_{k=0}^{h} (n / 2^(k + 1)) × O(k)`

### Вынесем константы

n не зависит от k, вынесем её за знак суммы:

`T(n) = O(n) × ∑_{k=0}^{h} (k / 2^(k + 1))`

`∑_{k=0}^{∞} (k / 2^k) = 2`

`T(n) = O(n) × O(1) = O(n)`
